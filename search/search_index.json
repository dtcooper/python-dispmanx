{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Python DispmanX \u2190 Hello and welcome! Here's the documentation for Python DispmanX, a pure Python 1 library for interacting with the Raspberry Pi's low-level video API. My hope is that you find it useful for creating all sorts of different apps, widgets, and graphical overlays for your Pi. I hope you'll have as much fun using it as I did writing it! A Word of Caution Currently, Python DispmanX is under development . While the API has mostly stabilized, it's recommended that you install the latest version from source, described below in the installation section. This documentation may not reflect the latest changes, or may include changes that are not yet available on PyPI . Beware! Quickstart \u2190 Follow the steps below to install the DispmanX library and run your first program using this library. Installation \u2190 Installation To install the DispmanX library from the Python Package Index (PyPI) , type the following at the command line, With NumPy support From Source with NumPy Without NumPy From Source Without NumPy # Install DispmanX with optional (and recommended) NumPy support pip install dispmanx [ numpy ] Installing From Source Recommended Until the API stabilizes, it's recommended that you install the latest version from source, described in the \"From Source With NumPy\" content tab above. # Or install directly from the latest developmental sources with NumPy support pip install git+https://github.com/dtcooper/python-dispmanx.git#egg = dispmanx [ numpy ] # Install DispmanX without NumPy pip install dispmanx # Or install directly from the latest developmental sources without NumPy pip install git+https://github.com/dtcooper/python-dispmanx.git pygame Example \u2190 To get going with your first pygame program, first install the library, pip install pygame Then try this out, pygame_test.py from random import randint import pygame from dispmanx import DispmanX def random_color_with_alpha (): return tuple ( randint ( 0 , 0xFF ) for _ in range ( 3 )) + ( randint ( 0x44 , 0xFF ),) display = DispmanX ( pixel_format = \"RGBA\" ) surface = pygame . image . frombuffer ( display . buffer , display . size , display . pixel_format ) clock = pygame . time . Clock () for _ in range ( 20 ): surface . fill ( random_color_with_alpha ()) display . update () clock . tick ( 2 ) If you see a DispmanXRuntimeError: No displays found! exception If you run into the following DispmanXRuntimeError running the code above, >>> from dispmanx import DispmanX >>> display = DispmanX () Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"/home/david/python-dispmanx/dispmanx/dispmanx.py\", line 205, in __init__ self._display = self.get_default_display() File \"/home/david/python-dispmanx/dispmanx/dispmanx.py\", line 421, in get_default_display raise DispmanXRuntimeError(\"No displays found! (Are you using the vc4-kms-v3d driver?)\") dispmanx.exceptions.DispmanXRuntimeError: No displays found! (Are you using the vc4-kms-v3d driver?) Then you'll need to follow the instructions here to address the issue. More examples are available on the recipes page. Use Cases \u2190 You may be asking why this library, when you could just pygame ? Here are some potential use cases: Transparent iverlays You may want to your program to have transparent overlays. pygame and SDL do not support them by default. With this library, you can write code that does just that! 2 Running in a headless environment pygame using its underlying SDL library requires either X11 or fbcon drivers on the Pi. While using the X11 driver works great, it requires a full desktop environment on your Pi. Furthermore, the fbcon driver appears to no longer be supported by pygame version 2. This library allows you to use familiar pygame idioms with the Raspberry Pi's native DispmanX layer. Using raw NumPy arrays You may want to directly interact with NumPy arrays of RGBA (or RGB) pixels with arbitrary imaging tool kits like Pillow or Cairo . Some examples of using raw NumPy arrays are available on the recipes page . My use case is retro style CRT TV hooked up to a Pi using the Pi-specific video player omxplayer complete with semi-transparent overlays for menus, \"channels,\" and subtitles 3 . What's Next? \u2190 Check out some code recipes that will show you how to use DispmanX with pygame , Pillow , Pycairo , and plain NumPy . Head over to the API documentation and read about the DispmanX class , the main entrypoint for this library. Read some of the additional information about this library. I say \"pure Python\" however this library uses Python's included ctypes library to perform \"foreign function calls\" to bcm_host.so \u2014 a C library included with Raspberry Pi OS to interface with the DispmanX layer directly. \u21a9 Fun fact, transparent overlays is the reason I wrote this package. \u21a9 While omxplayer does technically support subtitles, they don't seem to be working on the Raspberry Pi 4B . And besides, I wanted to render custom subtitles. \u21a9","title":"Intro"},{"location":"#welcome-to-python-dispmanx","text":"Hello and welcome! Here's the documentation for Python DispmanX, a pure Python 1 library for interacting with the Raspberry Pi's low-level video API. My hope is that you find it useful for creating all sorts of different apps, widgets, and graphical overlays for your Pi. I hope you'll have as much fun using it as I did writing it! A Word of Caution Currently, Python DispmanX is under development . While the API has mostly stabilized, it's recommended that you install the latest version from source, described below in the installation section. This documentation may not reflect the latest changes, or may include changes that are not yet available on PyPI . Beware!","title":"Welcome to Python DispmanX"},{"location":"#quickstart","text":"Follow the steps below to install the DispmanX library and run your first program using this library.","title":"Quickstart"},{"location":"#installation","text":"Installation To install the DispmanX library from the Python Package Index (PyPI) , type the following at the command line, With NumPy support From Source with NumPy Without NumPy From Source Without NumPy # Install DispmanX with optional (and recommended) NumPy support pip install dispmanx [ numpy ] Installing From Source Recommended Until the API stabilizes, it's recommended that you install the latest version from source, described in the \"From Source With NumPy\" content tab above. # Or install directly from the latest developmental sources with NumPy support pip install git+https://github.com/dtcooper/python-dispmanx.git#egg = dispmanx [ numpy ] # Install DispmanX without NumPy pip install dispmanx # Or install directly from the latest developmental sources without NumPy pip install git+https://github.com/dtcooper/python-dispmanx.git","title":"Installation"},{"location":"#pygame-example","text":"To get going with your first pygame program, first install the library, pip install pygame Then try this out, pygame_test.py from random import randint import pygame from dispmanx import DispmanX def random_color_with_alpha (): return tuple ( randint ( 0 , 0xFF ) for _ in range ( 3 )) + ( randint ( 0x44 , 0xFF ),) display = DispmanX ( pixel_format = \"RGBA\" ) surface = pygame . image . frombuffer ( display . buffer , display . size , display . pixel_format ) clock = pygame . time . Clock () for _ in range ( 20 ): surface . fill ( random_color_with_alpha ()) display . update () clock . tick ( 2 ) If you see a DispmanXRuntimeError: No displays found! exception If you run into the following DispmanXRuntimeError running the code above, >>> from dispmanx import DispmanX >>> display = DispmanX () Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"/home/david/python-dispmanx/dispmanx/dispmanx.py\", line 205, in __init__ self._display = self.get_default_display() File \"/home/david/python-dispmanx/dispmanx/dispmanx.py\", line 421, in get_default_display raise DispmanXRuntimeError(\"No displays found! (Are you using the vc4-kms-v3d driver?)\") dispmanx.exceptions.DispmanXRuntimeError: No displays found! (Are you using the vc4-kms-v3d driver?) Then you'll need to follow the instructions here to address the issue. More examples are available on the recipes page.","title":"pygame Example"},{"location":"#use-cases","text":"You may be asking why this library, when you could just pygame ? Here are some potential use cases: Transparent iverlays You may want to your program to have transparent overlays. pygame and SDL do not support them by default. With this library, you can write code that does just that! 2 Running in a headless environment pygame using its underlying SDL library requires either X11 or fbcon drivers on the Pi. While using the X11 driver works great, it requires a full desktop environment on your Pi. Furthermore, the fbcon driver appears to no longer be supported by pygame version 2. This library allows you to use familiar pygame idioms with the Raspberry Pi's native DispmanX layer. Using raw NumPy arrays You may want to directly interact with NumPy arrays of RGBA (or RGB) pixels with arbitrary imaging tool kits like Pillow or Cairo . Some examples of using raw NumPy arrays are available on the recipes page . My use case is retro style CRT TV hooked up to a Pi using the Pi-specific video player omxplayer complete with semi-transparent overlays for menus, \"channels,\" and subtitles 3 .","title":"Use Cases"},{"location":"#whats-next","text":"Check out some code recipes that will show you how to use DispmanX with pygame , Pillow , Pycairo , and plain NumPy . Head over to the API documentation and read about the DispmanX class , the main entrypoint for this library. Read some of the additional information about this library. I say \"pure Python\" however this library uses Python's included ctypes library to perform \"foreign function calls\" to bcm_host.so \u2014 a C library included with Raspberry Pi OS to interface with the DispmanX layer directly. \u21a9 Fun fact, transparent overlays is the reason I wrote this package. \u21a9 While omxplayer does technically support subtitles, they don't seem to be working on the Raspberry Pi 4B . And besides, I wanted to render custom subtitles. \u21a9","title":"What's Next?"},{"location":"api/","text":"API Documentation \u2190 The main entrypoint for the library is the DispmanX class as described below. DispmanX \u2190 DispmanX ( layer : int = 0 , display : Union [ None , int , Display ] = None , pixel_format : Literal [ \"RGB\" , \"ARGB\" , \"RGBA\" , \"RGBX\" , \"XRGB\" , \"RGBA16\" , \"RGB565\" ] = \"RGBA\" , buffer_type : Literal [ \"auto\" , \"numpy\" , \"ctypes\" ] = \"auto\" , ) The DispmanX Class You can use this class via the following, from dispmanx import DispmanX display = DispmanX () Parameters: Name Type Description Default layer int What layer to choose. For example, the default layer of Raspberry Pi OS Lite's terminal is -127 , while omxplayer is 0 . 0 display Union [None, int , Display ] Which display to use. Choices: None \u2014 the default display as returned by get_default_display() An int device number of a specific display A Display object, for example, returned by list_displays() ) None pixel_format Literal ['RGB', 'ARGB', 'RGBA', 'RGBX', 'XRGB', 'RGBA16', 'RGB565'] Pixel format for the object. Choices: 'RGB' \u2014 24-bit red, green, and blue 'ARGB' \u2014 32-bit alpha, red, green, and blue 'RGBA' \u2014 32-bit red, green, blue, and alpha 'RGBX' \u2014 32-bit red, green, blue and an unused ( X ) byte 'XRGB' \u2014 32-bit unused ( X ) byte, red, green, and blue 'RGBA16' \u2014 16-bit red, green, blue and alpha packed as 4 bits per channel (represented as unsigned 16-bit integers when using NumPy ) 'RGB565' \u2014 16-bit red, green, blue packed as follows: 5 bits red, 6 bits green, 5 bits green (represented as unsigned 16-bit integers when using NumPy ) 'RGBA' buffer_type Literal ['auto', 'numpy', 'ctypes'] Type of buffer to write to the display from. Choices: 'auto' \u2014 defaults to a NumPy array if NumPy is available, otherwise a ctypes Array of c_char as described below 'numpy' \u2014 a NumPy array 'ctypes \u2014 a ctypes Array of c_char created with create_string_buffer() 'auto' Raises: Type Description DispmanXError A user error occured by specifying an incorrect argument. DispmanXRuntimeError A serious error occured with the underlying DispmanX layer on your PI. Attributes: Name Type Description buffer A buffer representing underlying raw pixel data. It will be a NumPy array or ctypes Array of c_char depending on the value of the buffer_type argument. buffer_type str Whether the buffer is a NumPy array or a ctypes Array . (Either \"numpy\" or \"ctypes\" .) display Display The display for which this object is attached to pixel_format str The pixel format for this object. (One of \"RGB\" , \"ARGB\" , \"RGBA\" , \"RGBX\" , \"XRGB\" , \"RGBA16\" or \"RGB565\" .) size Size The Size object representing the dimensions of the current display. width int The width of the current display. height int The height of the current display. layer int The layer of this object. destroyed bool Whether or not this object has been destroyed, is currently unusable, and no longer is available to display. destroy \u2190 destroy () -> None Destroy this DispmanX object If the object is already destroyed, the operation will do nothing. Raises: Type Description DispmanXRuntimeError Raised if there's an error destroying any of the underlying resources for the object get_default_display classmethod \u2190 get_default_display () -> Display Get the default Display . This is both the first display returned by DispmanX layer, and the one used when creating DispmanX objects by default. Returns: Type Description Display The default Display . list_displays classmethod \u2190 list_displays () -> list [ Display ] Get a list of available Displays . Example for display in DispmanX . list_display (): print ( f \" { display . device_id } : { display . name } \" ) Returns: Type Description list [ Display ] List of available Displays . Raises: Type Description DispmanXRuntimeError Raised if no devices are found, or there's an error while getting the list of displays. update \u2190 update () -> None Update the pixels based on what's in the buffer Raises: Type Description DispmanXRuntimeError Raises if there's an error writing to the video memory Other Classes \u2190 Display \u2190 Bases: NamedTuple Returned by various interactions with the DispmanX class. Not instantiated directly. Attributes: Name Type Description device_id int The numeric ID associated with this display. You can use this to instantiate a DispmanX for this display. name str The string representation of this display, for example \"Main LCD\" , \"HDMI 0\" , or \"Composite\" to name a few. size Size The size of this display. Size \u2190 Bases: NamedTuple Returned by various interactions with the DismpanX and Display classes. Not instantiated directly. Attributes: Name Type Description width int The width component height int The height component Exceptions \u2190 DispmanXError \u2190 Bases: Exception Raised when a recoverable error occurs with the underlying DispmanX library. Likely a programmer error. You can try whatever you were doing again and correcting the offending behavior. # Imported from dispmanx module from dispmanx import DispmanXError DispmanXRuntimeError \u2190 Bases: RuntimeError Raised when an irrecoverable error occurs with the underlying DispmanX library. Under normal circumstances, you should destroy any DispmanX objects you've instantiated when one of these exceptions gets raises. Or, your program should cleanly exit. # Imported from dispmanx module from dispmanx import DispmanXRuntimeError","title":"API Docs"},{"location":"api/#api-documentation","text":"The main entrypoint for the library is the DispmanX class as described below.","title":"API Documentation"},{"location":"api/#dispmanx.DispmanX","text":"DispmanX ( layer : int = 0 , display : Union [ None , int , Display ] = None , pixel_format : Literal [ \"RGB\" , \"ARGB\" , \"RGBA\" , \"RGBX\" , \"XRGB\" , \"RGBA16\" , \"RGB565\" ] = \"RGBA\" , buffer_type : Literal [ \"auto\" , \"numpy\" , \"ctypes\" ] = \"auto\" , ) The DispmanX Class You can use this class via the following, from dispmanx import DispmanX display = DispmanX () Parameters: Name Type Description Default layer int What layer to choose. For example, the default layer of Raspberry Pi OS Lite's terminal is -127 , while omxplayer is 0 . 0 display Union [None, int , Display ] Which display to use. Choices: None \u2014 the default display as returned by get_default_display() An int device number of a specific display A Display object, for example, returned by list_displays() ) None pixel_format Literal ['RGB', 'ARGB', 'RGBA', 'RGBX', 'XRGB', 'RGBA16', 'RGB565'] Pixel format for the object. Choices: 'RGB' \u2014 24-bit red, green, and blue 'ARGB' \u2014 32-bit alpha, red, green, and blue 'RGBA' \u2014 32-bit red, green, blue, and alpha 'RGBX' \u2014 32-bit red, green, blue and an unused ( X ) byte 'XRGB' \u2014 32-bit unused ( X ) byte, red, green, and blue 'RGBA16' \u2014 16-bit red, green, blue and alpha packed as 4 bits per channel (represented as unsigned 16-bit integers when using NumPy ) 'RGB565' \u2014 16-bit red, green, blue packed as follows: 5 bits red, 6 bits green, 5 bits green (represented as unsigned 16-bit integers when using NumPy ) 'RGBA' buffer_type Literal ['auto', 'numpy', 'ctypes'] Type of buffer to write to the display from. Choices: 'auto' \u2014 defaults to a NumPy array if NumPy is available, otherwise a ctypes Array of c_char as described below 'numpy' \u2014 a NumPy array 'ctypes \u2014 a ctypes Array of c_char created with create_string_buffer() 'auto' Raises: Type Description DispmanXError A user error occured by specifying an incorrect argument. DispmanXRuntimeError A serious error occured with the underlying DispmanX layer on your PI. Attributes: Name Type Description buffer A buffer representing underlying raw pixel data. It will be a NumPy array or ctypes Array of c_char depending on the value of the buffer_type argument. buffer_type str Whether the buffer is a NumPy array or a ctypes Array . (Either \"numpy\" or \"ctypes\" .) display Display The display for which this object is attached to pixel_format str The pixel format for this object. (One of \"RGB\" , \"ARGB\" , \"RGBA\" , \"RGBX\" , \"XRGB\" , \"RGBA16\" or \"RGB565\" .) size Size The Size object representing the dimensions of the current display. width int The width of the current display. height int The height of the current display. layer int The layer of this object. destroyed bool Whether or not this object has been destroyed, is currently unusable, and no longer is available to display.","title":"DispmanX"},{"location":"api/#dispmanx.dispmanx.DispmanX.destroy","text":"destroy () -> None Destroy this DispmanX object If the object is already destroyed, the operation will do nothing. Raises: Type Description DispmanXRuntimeError Raised if there's an error destroying any of the underlying resources for the object","title":"destroy()"},{"location":"api/#dispmanx.dispmanx.DispmanX.get_default_display","text":"get_default_display () -> Display Get the default Display . This is both the first display returned by DispmanX layer, and the one used when creating DispmanX objects by default. Returns: Type Description Display The default Display .","title":"get_default_display()"},{"location":"api/#dispmanx.dispmanx.DispmanX.list_displays","text":"list_displays () -> list [ Display ] Get a list of available Displays . Example for display in DispmanX . list_display (): print ( f \" { display . device_id } : { display . name } \" ) Returns: Type Description list [ Display ] List of available Displays . Raises: Type Description DispmanXRuntimeError Raised if no devices are found, or there's an error while getting the list of displays.","title":"list_displays()"},{"location":"api/#dispmanx.dispmanx.DispmanX.update","text":"update () -> None Update the pixels based on what's in the buffer Raises: Type Description DispmanXRuntimeError Raises if there's an error writing to the video memory","title":"update()"},{"location":"api/#other-classes","text":"","title":"Other Classes"},{"location":"api/#dispmanx.dispmanx.Display","text":"Bases: NamedTuple Returned by various interactions with the DispmanX class. Not instantiated directly. Attributes: Name Type Description device_id int The numeric ID associated with this display. You can use this to instantiate a DispmanX for this display. name str The string representation of this display, for example \"Main LCD\" , \"HDMI 0\" , or \"Composite\" to name a few. size Size The size of this display.","title":"Display"},{"location":"api/#dispmanx.dispmanx.Size","text":"Bases: NamedTuple Returned by various interactions with the DismpanX and Display classes. Not instantiated directly. Attributes: Name Type Description width int The width component height int The height component","title":"Size"},{"location":"api/#exceptions","text":"","title":"Exceptions"},{"location":"api/#dispmanx.DispmanXError","text":"Bases: Exception Raised when a recoverable error occurs with the underlying DispmanX library. Likely a programmer error. You can try whatever you were doing again and correcting the offending behavior. # Imported from dispmanx module from dispmanx import DispmanXError","title":"DispmanXError"},{"location":"api/#dispmanx.DispmanXRuntimeError","text":"Bases: RuntimeError Raised when an irrecoverable error occurs with the underlying DispmanX library. Under normal circumstances, you should destroy any DispmanX objects you've instantiated when one of these exceptions gets raises. Or, your program should cleanly exit. # Imported from dispmanx module from dispmanx import DispmanXRuntimeError","title":"DispmanXRuntimeError"},{"location":"license/","text":"Author and License \u2190 Author \u2190 Hi! I'm David Cooper. I'm the author of Python DispmanX. I'm reachable for feedback or questions at david@jew.pizza . I'm a software engineer turned radio personality . I used to be a professional programmer and then engineering manager, but coding is now just a hobby. My mother thinks I'm crazy . Find out more or listen at www.jew.pizza . License \u2190 Python DispmanX is offered under the permissive MIT license below, MIT License Copyright (c) 2022, David Cooper <david@dtcooper.com> Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Author & License"},{"location":"license/#author-and-license","text":"","title":"Author and License"},{"location":"license/#author","text":"Hi! I'm David Cooper. I'm the author of Python DispmanX. I'm reachable for feedback or questions at david@jew.pizza . I'm a software engineer turned radio personality . I used to be a professional programmer and then engineering manager, but coding is now just a hobby. My mother thinks I'm crazy . Find out more or listen at www.jew.pizza .","title":"Author"},{"location":"license/#license","text":"Python DispmanX is offered under the permissive MIT license below, MIT License Copyright (c) 2022, David Cooper <david@dtcooper.com> Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"more-info/","text":"Additional Information \u2190 Below is more information about the Python DispmanX library, including what's supported, how to install the necessary requirements ( bcm_host.so ), and some acknowledgements. Python, OS and Device Version Support \u2190 OS Support: The latest versions of 32- and 64- bit Raspberry Pi OS are supported. As of the time of this writing, that's based on Debian Bullseye (11.x) . Python Version The minimum version of Python supported is 3.9. That's the default version installed on the latest Raspberry Pi OS (Bullseye). Raspberry Pi Versions This library should work on any version of the Pi, but I've specifically tested, Raspberry Pi 4 B Raspberry Pi 3 B+ Raspberry Pi 3 B Raspberry Pi 2 Raspberry Pi B If you're using an older version of Python, Raspberry Pi OS, and/or a different OS entirely, you can always use Docker on your Pi. See the section on Docker and Compose below. Fixing No displays found! Exception \u2190 If you have display(s) hooked up to your Raspberry Pi, but you run into an error that looks something like this, >>> from dispmanx import DispmanX >>> display = DispmanX () Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"/home/david/python-dispmanx/dispmanx/dispmanx.py\", line 205, in __init__ self._display = self.get_default_display() File \"/home/david/python-dispmanx/dispmanx/dispmanx.py\", line 421, in get_default_display raise DispmanXRuntimeError(\"No displays found! (Are you using the vc4-kms-v3d driver?)\") dispmanx.exceptions.DispmanXRuntimeError: No displays found! (Are you using the vc4-kms-v3d driver?) Then your Pi may be running in so-called \"Full KMS\" video mode. In order for your Pi to run its video layer on top of DispmanX, you'll need to change a configuration value in /boot/config.txt to switch to \"Fake FMS\" mode. (Don't let the word \"fake\" scare you.) /boot/config.txt # Enable DRM VC4 V3D driver dtoverlay=vc4-kms-v3d <- change to: dtoverlay=vc4-fkms-v3d max_framebuffers=2 Afterwards, reboot. Alternatively, you can follow these commands to perform the operation manually, # Modify the video driver: vc4-kms-v3d -> vc4-fkms-v3d sudo sed -i 's/^dtoverlay=vc4-kms-v3d/dtoverlay=vc4-fkms-v3d/' /boot/config.txt sudo reboot # Reboot your Pi Et voil\u00e0, that should fix that! ctypes and bcm_host.so \u2190 While Python DispmanX is written completely in Python, it uses Python's included ctypes library to perform \"foreign function calls\" to bcm_host.so . In short, it calls the C library included with Raspberry Pi OS to interface with the DispmanX layer directly. The library bcm_host.so is available through the libraspberrypi0 Debian package, which should have come installed on your Pi if you used Raspberry Pi OS. If that's not available, you can always use Docker following the instructions in the Docker and Compose section below. Docker and Compose \u2190 Both Docker and Docker Compose work great. They're actually how I run the library. Details below. Using Docker \u2190 If the version of Raspberry Pi OS that you're using isn't supported by this library or you're using a different operating system altogether, you can always use Docker . Docker is supported on both 32- and 64-bit architectures. The base container for Debian Bullseye doesn't by default contain the necessary libraspberrypi0 package as described above. So, you'll need to either add the \"Raspbian Repository\" , or use my minimal Raspberry Pi OS base containers . Three variants that will work are provided. The device /dev/vchiq needs to be exposed to container. For the Debian image, you'll need to install pip yourself. Three images are listed in the table below. Description Image Name Python 3.9 dtcooper/raspberrypi-os:python3.9 Python 3.10 dtcooper/raspberrypi-os:python3.10 Debian (Bullseye) dtcooper/raspberrypi-os:bullseye For example to use the Python 3.9 container with a script called test.py in your current directory run this at the command line, docker run -it \\ -v \"./test.py:/test.py\" \\ --device /dev/vchiq:/dev/vchiq \\ dtcooper/raspberrypi-os:python3.9 \\ bash # Now in the container pip install dispmanx [ numpy ] python /test.py Using Compose \u2190 Using Docker Compose also works great. You'll need to similarly expose the /dev/vchiq device, however. Here's a sample docker-compose.yml file, docker-compose.yml services : dispmanx : #image: <Your image based on dtcooper/raspberrypi-os:python3.9> devices : - /dev/vchiq:/dev/vchiq Acknowledgements \u2190 Several projects were used as reference in the development of Python DispmanX. Some of the main ones are described below. PyDispmanx \u2190 First and foremost, let me acknowledge the great work Tim Clark put into PyDispmanx . PyDispmanx is another Python library available that functions somewhat similarly. Honestly, it's great and I would recommend it! I owe a debt of gratitude to its author, for two reasons, First and foremost, showing me that interfacing with the Pi's DispmanX API via Python is possible; and Being available to peep into its source code. While it's perhaps the best alternative to this project, some reasons I've chosen to re-write from scratch are: To provide a ctypes pure Python interface; To provide a more complete interface to DispmanX; To provide documentation on how to use the thing with popular Python graphics libraries; To publish regular, stable, and tested releases to PyPI ; PyDispmanx appears to be an unstable work in progress. For example, by its own author's admission in the project README, he says \"[he] probably wouldn't install this system wide yet\"; and Writing code is fun! raspidmx \u2190 The Broadcom hardware interface library which provides the DispmanX APIs is very poorly documented. One of the first usable set of open source C programming language example programs were by a developer named Andrew Duncan . He calls the suite raspidmx . Andrew provided a set of \"programs [that could] be used as a starting point for anyone wanting to make use of DispmanX.\" Some of the common code from raspidmx is the underlying code that drives PyDispmanx . I owe a debt of gratitude to its author, since peeping into raspidmx 's source tree is what helped figure out how to call the DispmanX APIs from Python. picamera \u2190 The picamera Python library interfaces with the Pi's Camera Module . Its source code contains several parts that interface with the Pi's APIs including the DispmanX layer contained in the bcm_host.so shared library. In particular picamera 's source file bcm_host.py was used as inspiration for how to interact with DispmanX via ctypes . Project Roadmap \u2190 Publish package to PyPI Add API docs using MkDocs, Material for MkDocs, mkdocstrings Call destroy functions in bcm_host.h Support additional pixel types Allow multiple layers, and different displays Support custom dimensions and offsets \u2013 API supports it, but requires weird multiples of 16 or 32, as documented here . This requires testing, because anecdotally it seems to work with smaller multiples. Tests run over SSH onto my home pi \u2014 GitHub actions won't work, since they don't support DispmanX APIs","title":"Additional Info"},{"location":"more-info/#additional-information","text":"Below is more information about the Python DispmanX library, including what's supported, how to install the necessary requirements ( bcm_host.so ), and some acknowledgements.","title":"Additional Information"},{"location":"more-info/#python-os-and-device-version-support","text":"OS Support: The latest versions of 32- and 64- bit Raspberry Pi OS are supported. As of the time of this writing, that's based on Debian Bullseye (11.x) . Python Version The minimum version of Python supported is 3.9. That's the default version installed on the latest Raspberry Pi OS (Bullseye). Raspberry Pi Versions This library should work on any version of the Pi, but I've specifically tested, Raspberry Pi 4 B Raspberry Pi 3 B+ Raspberry Pi 3 B Raspberry Pi 2 Raspberry Pi B If you're using an older version of Python, Raspberry Pi OS, and/or a different OS entirely, you can always use Docker on your Pi. See the section on Docker and Compose below.","title":"Python, OS and Device Version Support"},{"location":"more-info/#fixing-no-displays-found-exception","text":"If you have display(s) hooked up to your Raspberry Pi, but you run into an error that looks something like this, >>> from dispmanx import DispmanX >>> display = DispmanX () Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"/home/david/python-dispmanx/dispmanx/dispmanx.py\", line 205, in __init__ self._display = self.get_default_display() File \"/home/david/python-dispmanx/dispmanx/dispmanx.py\", line 421, in get_default_display raise DispmanXRuntimeError(\"No displays found! (Are you using the vc4-kms-v3d driver?)\") dispmanx.exceptions.DispmanXRuntimeError: No displays found! (Are you using the vc4-kms-v3d driver?) Then your Pi may be running in so-called \"Full KMS\" video mode. In order for your Pi to run its video layer on top of DispmanX, you'll need to change a configuration value in /boot/config.txt to switch to \"Fake FMS\" mode. (Don't let the word \"fake\" scare you.) /boot/config.txt # Enable DRM VC4 V3D driver dtoverlay=vc4-kms-v3d <- change to: dtoverlay=vc4-fkms-v3d max_framebuffers=2 Afterwards, reboot. Alternatively, you can follow these commands to perform the operation manually, # Modify the video driver: vc4-kms-v3d -> vc4-fkms-v3d sudo sed -i 's/^dtoverlay=vc4-kms-v3d/dtoverlay=vc4-fkms-v3d/' /boot/config.txt sudo reboot # Reboot your Pi Et voil\u00e0, that should fix that!","title":"Fixing No displays found! Exception"},{"location":"more-info/#ctypes-and-bcm_hostso","text":"While Python DispmanX is written completely in Python, it uses Python's included ctypes library to perform \"foreign function calls\" to bcm_host.so . In short, it calls the C library included with Raspberry Pi OS to interface with the DispmanX layer directly. The library bcm_host.so is available through the libraspberrypi0 Debian package, which should have come installed on your Pi if you used Raspberry Pi OS. If that's not available, you can always use Docker following the instructions in the Docker and Compose section below.","title":"ctypes and bcm_host.so"},{"location":"more-info/#docker-and-compose","text":"Both Docker and Docker Compose work great. They're actually how I run the library. Details below.","title":"Docker and Compose"},{"location":"more-info/#using-docker","text":"If the version of Raspberry Pi OS that you're using isn't supported by this library or you're using a different operating system altogether, you can always use Docker . Docker is supported on both 32- and 64-bit architectures. The base container for Debian Bullseye doesn't by default contain the necessary libraspberrypi0 package as described above. So, you'll need to either add the \"Raspbian Repository\" , or use my minimal Raspberry Pi OS base containers . Three variants that will work are provided. The device /dev/vchiq needs to be exposed to container. For the Debian image, you'll need to install pip yourself. Three images are listed in the table below. Description Image Name Python 3.9 dtcooper/raspberrypi-os:python3.9 Python 3.10 dtcooper/raspberrypi-os:python3.10 Debian (Bullseye) dtcooper/raspberrypi-os:bullseye For example to use the Python 3.9 container with a script called test.py in your current directory run this at the command line, docker run -it \\ -v \"./test.py:/test.py\" \\ --device /dev/vchiq:/dev/vchiq \\ dtcooper/raspberrypi-os:python3.9 \\ bash # Now in the container pip install dispmanx [ numpy ] python /test.py","title":"Using Docker"},{"location":"more-info/#using-compose","text":"Using Docker Compose also works great. You'll need to similarly expose the /dev/vchiq device, however. Here's a sample docker-compose.yml file, docker-compose.yml services : dispmanx : #image: <Your image based on dtcooper/raspberrypi-os:python3.9> devices : - /dev/vchiq:/dev/vchiq","title":"Using Compose"},{"location":"more-info/#acknowledgements","text":"Several projects were used as reference in the development of Python DispmanX. Some of the main ones are described below.","title":"Acknowledgements"},{"location":"more-info/#pydispmanx","text":"First and foremost, let me acknowledge the great work Tim Clark put into PyDispmanx . PyDispmanx is another Python library available that functions somewhat similarly. Honestly, it's great and I would recommend it! I owe a debt of gratitude to its author, for two reasons, First and foremost, showing me that interfacing with the Pi's DispmanX API via Python is possible; and Being available to peep into its source code. While it's perhaps the best alternative to this project, some reasons I've chosen to re-write from scratch are: To provide a ctypes pure Python interface; To provide a more complete interface to DispmanX; To provide documentation on how to use the thing with popular Python graphics libraries; To publish regular, stable, and tested releases to PyPI ; PyDispmanx appears to be an unstable work in progress. For example, by its own author's admission in the project README, he says \"[he] probably wouldn't install this system wide yet\"; and Writing code is fun!","title":"PyDispmanx"},{"location":"more-info/#raspidmx","text":"The Broadcom hardware interface library which provides the DispmanX APIs is very poorly documented. One of the first usable set of open source C programming language example programs were by a developer named Andrew Duncan . He calls the suite raspidmx . Andrew provided a set of \"programs [that could] be used as a starting point for anyone wanting to make use of DispmanX.\" Some of the common code from raspidmx is the underlying code that drives PyDispmanx . I owe a debt of gratitude to its author, since peeping into raspidmx 's source tree is what helped figure out how to call the DispmanX APIs from Python.","title":"raspidmx"},{"location":"more-info/#picamera","text":"The picamera Python library interfaces with the Pi's Camera Module . Its source code contains several parts that interface with the Pi's APIs including the DispmanX layer contained in the bcm_host.so shared library. In particular picamera 's source file bcm_host.py was used as inspiration for how to interact with DispmanX via ctypes .","title":"picamera"},{"location":"more-info/#project-roadmap","text":"Publish package to PyPI Add API docs using MkDocs, Material for MkDocs, mkdocstrings Call destroy functions in bcm_host.h Support additional pixel types Allow multiple layers, and different displays Support custom dimensions and offsets \u2013 API supports it, but requires weird multiples of 16 or 32, as documented here . This requires testing, because anecdotally it seems to work with smaller multiples. Tests run over SSH onto my home pi \u2014 GitHub actions won't work, since they don't support DispmanX APIs","title":"Project Roadmap"},{"location":"recipes/","text":"Code Recipes \u2190 Below are a few code recipes for pygame , Pillow , Pycairo , and plain NumPy to get you started. If you're unsure how to install this library, check out the installation section . pygame Example \u2190 First install pygame , pip install pygame Then run this program, pillow_test.py from random import randint import pygame from dispmanx import DispmanX def random_color_with_alpha (): return tuple ( randint ( 0 , 0xFF ) for _ in range ( 3 )) + ( randint ( 0x44 , 0xFF ),) display = DispmanX ( pixel_format = \"RGBA\" ) surface = pygame . image . frombuffer ( display . buffer , display . size , display . pixel_format ) clock = pygame . time . Clock () for _ in range ( 20 ): surface . fill ( random_color_with_alpha ()) display . update () clock . tick ( 2 ) Pillow Example \u2190 NumPy Required For this example to work correctly, ensure you've installed NumPy . The easiest way to do that with pip is: pip install dispmanx [ numpy ] First install Pillow , pip install Pillow Then run this program, pillow_test.py import time from random import randint import numpy from PIL import Image , ImageDraw from dispmanx import DispmanX def random_color_with_alpha (): return tuple ( randint ( 0 , 0xFF ) for _ in range ( 3 )) + ( randint ( 0x44 , 0xFF ),) display = DispmanX ( pixel_format = \"RGBA\" , buffer_type = \"numpy\" ) image = Image . new ( mode = display . pixel_format , size = display . size ) draw = ImageDraw . Draw ( image ) for _ in range ( 20 ): draw . rectangle ((( 0 , 0 ), ( image . size )), fill = random_color_with_alpha ()) numpy . copyto ( display . buffer , image ) display . update () time . sleep ( 0.5 ) A Note About Performance This example includes copying an RGBA array of pixels from a Pillow rendering, rather than editing an array in-place like the other examples. This is inherently slow, so you're not going to get as high frame rates as in the pygame example. If you know a way to do in-place modification of numpy arrays with Pillow, let me know by filing a GitHub issue! Pycairo Example \u2190 First install Pycairo , pip install pycairo Then run this program, pycairo_test.py from random import uniform import time from cairo import ImageSurface , FORMAT_RGB24 , Context from dispmanx import DispmanX def random_color (): return tuple ( uniform ( 0 , 1 ) for _ in range ( 3 )) display = DispmanX ( pixel_format = \"RGBX\" ) width , height = display . size surface = ImageSurface . create_for_data ( display . buffer , FORMAT_RGB24 , width , height ) context = Context ( surface ) for _ in range ( 20 ): context . set_source_rgba ( * random_color ()) context . rectangle ( 0 , 0 , display . width - 1 , display . height - 1 ) context . fill () display . update () time . sleep ( 0.5 ) NumPy Example \u2190 All you need is NumPy for this one. First, install it, pip install numpy Then run this program to create a fake static effect, numpy_static.py import time import numpy from dispmanx import DispmanX import numpy display = DispmanX ( pixel_format = \"RGB565\" , buffer_type = \"numpy\" ) high = numpy . iinfo ( display . buffer . dtype ) . max + 1 # white pixel rng = numpy . random . default_rng () while True : static = rng . integers ( low = 0 , high = high , size = display . buffer . shape , dtype = display . buffer . dtype ) numpy . copyto ( display . buffer , static ) # Simulates TV static display . update () time . sleep ( 0.0135 ) What's Next? \u2190 Now that you're an expert, check out the API documentation .","title":"Recipes"},{"location":"recipes/#code-recipes","text":"Below are a few code recipes for pygame , Pillow , Pycairo , and plain NumPy to get you started. If you're unsure how to install this library, check out the installation section .","title":"Code Recipes"},{"location":"recipes/#pygame-example","text":"First install pygame , pip install pygame Then run this program, pillow_test.py from random import randint import pygame from dispmanx import DispmanX def random_color_with_alpha (): return tuple ( randint ( 0 , 0xFF ) for _ in range ( 3 )) + ( randint ( 0x44 , 0xFF ),) display = DispmanX ( pixel_format = \"RGBA\" ) surface = pygame . image . frombuffer ( display . buffer , display . size , display . pixel_format ) clock = pygame . time . Clock () for _ in range ( 20 ): surface . fill ( random_color_with_alpha ()) display . update () clock . tick ( 2 )","title":"pygame Example"},{"location":"recipes/#pillow-example","text":"NumPy Required For this example to work correctly, ensure you've installed NumPy . The easiest way to do that with pip is: pip install dispmanx [ numpy ] First install Pillow , pip install Pillow Then run this program, pillow_test.py import time from random import randint import numpy from PIL import Image , ImageDraw from dispmanx import DispmanX def random_color_with_alpha (): return tuple ( randint ( 0 , 0xFF ) for _ in range ( 3 )) + ( randint ( 0x44 , 0xFF ),) display = DispmanX ( pixel_format = \"RGBA\" , buffer_type = \"numpy\" ) image = Image . new ( mode = display . pixel_format , size = display . size ) draw = ImageDraw . Draw ( image ) for _ in range ( 20 ): draw . rectangle ((( 0 , 0 ), ( image . size )), fill = random_color_with_alpha ()) numpy . copyto ( display . buffer , image ) display . update () time . sleep ( 0.5 ) A Note About Performance This example includes copying an RGBA array of pixels from a Pillow rendering, rather than editing an array in-place like the other examples. This is inherently slow, so you're not going to get as high frame rates as in the pygame example. If you know a way to do in-place modification of numpy arrays with Pillow, let me know by filing a GitHub issue!","title":"Pillow Example"},{"location":"recipes/#pycairo-example","text":"First install Pycairo , pip install pycairo Then run this program, pycairo_test.py from random import uniform import time from cairo import ImageSurface , FORMAT_RGB24 , Context from dispmanx import DispmanX def random_color (): return tuple ( uniform ( 0 , 1 ) for _ in range ( 3 )) display = DispmanX ( pixel_format = \"RGBX\" ) width , height = display . size surface = ImageSurface . create_for_data ( display . buffer , FORMAT_RGB24 , width , height ) context = Context ( surface ) for _ in range ( 20 ): context . set_source_rgba ( * random_color ()) context . rectangle ( 0 , 0 , display . width - 1 , display . height - 1 ) context . fill () display . update () time . sleep ( 0.5 )","title":"Pycairo Example"},{"location":"recipes/#numpy-example","text":"All you need is NumPy for this one. First, install it, pip install numpy Then run this program to create a fake static effect, numpy_static.py import time import numpy from dispmanx import DispmanX import numpy display = DispmanX ( pixel_format = \"RGB565\" , buffer_type = \"numpy\" ) high = numpy . iinfo ( display . buffer . dtype ) . max + 1 # white pixel rng = numpy . random . default_rng () while True : static = rng . integers ( low = 0 , high = high , size = display . buffer . shape , dtype = display . buffer . dtype ) numpy . copyto ( display . buffer , static ) # Simulates TV static display . update () time . sleep ( 0.0135 )","title":"NumPy Example"},{"location":"recipes/#whats-next","text":"Now that you're an expert, check out the API documentation .","title":"What's Next?"}]}